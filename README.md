//App Startup//
fun (start game)

//Death Animation//
public fun MainActivity (player)
public fun MainActivity(animation): Unit{
    val blood = exp(x=30) and exp(y=30)
    player health = local val
    var death = (player health = 0)
    when death = true
    when death is true: buildString {
        return (blood 1 = TODO(x = 200) and TODO(y = 300)
        blood 2 =  TODO(x = 210) and TODO(y = 290)
        blood 3 =   TODO(x = 220) and TODO(y = 290)
        blood 4 =  TODO(x = 215) and TODO(y = 295)
        blood 5 =  TODO(x = 185) and TODO(y = 270)
        blood 6 = TODO(x = 190) and TODO(y = 305)
        blood 7 =  TODO(x = 175) and TODO(y = 2850)
        blood 8 =  TODO(x = 205) and TODO(y = 305)))
    }

   //map generation// {
    generateSequence bulidmap
            {
                val Floor 1 = 0x to 2000x and 0y to 1000y R.color (black)
                val Floor 2 = 0x to 2000x and 1000y to 2000y R.color (black)
                val Floor 3 = 0x to 2000x and 2000y to 3000y R.color (black)
                val Floor 4 = 0x to 2000x and 3000y to 8000y
            }

        //Clump generation//
    generate sequence "build clump"
        combine result (times = 100) '
        (final dimension = 1,000 by 1,000 units)
        (generate clump as circle shape)
        {var random = result black square
        (black square = 10x wide 10y tall)
        var random, result = orange square
        (orange square = 10x wide 10y tall)
        var random, result = green square
        (green square = 10x wide 10y tall)
        var random, result = red square
        (red square = 10x wide 10y tall)
        var random, result = pink square
        (pink square = 10x wide 10y tall)
        var random, result = blue square
        (blue square = 10x wide 10y tall)
        var random, result = white square
        (white square = 10x wide 10y tall)
        var random, result = black square
        (black square = 10x wide 10y tall)
        var random, result = violet square
        (violet square = 10x wide 10y tall)
        var random, result = cyan square
        (cyan square = 10x wide 10y tall)
        var random, result = brown square
        (brown square = 10x wide 10y tall)
        var random, result = purple square
        (purple square = 10x wide 10y tall)
        var random, result = lime square
        (lime square = 10x wide 10y tall)
        pick: random, 100 times
        add result 100 times to clump
    }

    //Player values//

//Opponents and Friends//
fun Attack
{(action = hit) = 0 health
    var is (x=(Team One Players) hit y=(Team Two Players))
    if hit = true, Team Two Players = 0 health
    var is (x=(Team Two Players) hit y=(Team One Players) if hit = true)
    if hit = true, Team One Players = 0 health
    (Team One Players) hit (Team One Players) = Always false
    (Team Two Players) hit (Team One Players)= Always false
    (Team One Players) hit (Team Two Players) = Always true
    (Team Two Players) hit (Team One Players) = Always true
    class (teamonefriends) {
        1 "Random Players" in Team One Players
        assert Random Players as }
    class (team two friends) {
        1 "Random Players" in Team Two Players
        val always = indefinately
    }
    fun OpposingTeam
    {
       Val Goal = Stop OpposingTeam
        if OpposingTeam "all Players" hit = true
       var return "you win" to Team Two Player string: ((if Team One Players all Players hit = false) and (RoundOver = true))
        return "you win" to Team One Player = true string: ((if Team Two Players all Players hit = false) and RoundOver = true))
       val LosingPlayer = if "you win" = true return "You Lose" to OpposingTeam all Players:
        (Team Two Players) is OpposingTeam to (Team One Players)
        (Team One Players) is OpposingTeam to (Team Two Players)
    }
    Object Bow
            Object Arrow
            If radius of "Random Player" = 1 from arrow
    invoke hit as true
}
return reward if Course is complete
    var reward = TNT
    object TNT
    {
        if blow = true, erase block in 50 radius
      var  blow animation = (if blow = true return dots 10 units by 10 units blue green red pink)
    }

    //Rounds//
    fun {
        BigExplosionAnimation
        {obstacles move (random 30-50 unitsx) and (random 30-50 units y)}
        every 1 s, LosingPlayer +10 blocks=y and + X blocks=x (pick random: 1-5 blocks)
        when LosingPlayer reach max 8000=y, (every 1s LosingPlayer -10 blocks=y and X blocks=x (Pick random: 1-5 blocks))
      val DyingPlayers = invoke hit as true 1/2 Players for LosingPlayers when y=0),
        val LosingMessage= Display "You die" for Losing Players
    }
    fun RoundOver
    val BigExplosionAnimation = all Players
    Random Point Except all "you win" Player
    {if all Players hit = true in Team one Players or Team Two Players
        invoke "Big Explosion"

    }
    fun RoundOne {
        var RoundStart
        var MaxRoundDuration =500s  (if all Players hit = true) (if Difficulty is Hard, add 100s to max Round Duration)
        var DifficultyHardMapgeneration
        {obstacle Count = 20
                MaxRoundDuration = 600s
        }
        var DifficultyMediumMapgeneration
        {Obstacle Count = 15
            MaxRoundDuration = 550s
        }
        var DifficultyEasyMapgeneration {
            Obstacle Count = 10
            MaxRoundDuration = 500s
                    Rewards
        }
    }


    //Wall Development//
    fun (BuildWall)
    {val brick = ((x=100 units) and (y=100 units)
    20 Brick at ((x=0 to x=2000) and (y=0 to y=0))
    80 Brick at ((x=0 to x=0) and (y=0 to y = 8000))
    80 Brick at ((x=2000 to x=2000) and (y=0 to y=8000))
    20 Brick at ((x=0 to x=2000) and (y=8000 to y=8000))
    20 Brick at ((x=100 to x=2000) and (y=1000 to y=1000))
    20 Brick at ((x=0 to x=1900) and (y=1000 to y=1000))
        Brick Image = 
    }

    //Players Run A Course//
    random
    var on wall = always true
        val obstacle
    object (obstacle) one =
    object (obstacle) Two =
    object (obstacle) Three =
    object (obstacle) Four =
    object (obstacle) Five =
    object (obstacle) Six =
    object (obstacle) Seven =

}


        //Team Formation//
        {byteArrayOf (Team One, "attackers")
               buildString (combine all Players)
            var "Random Players" = Pick (Player 1) or (Player 2) or (Player 3) or (Player 4) or (Player 5) or (Player 6) or (Player 7) or (Player 8)
            var "all Players" = TODO Players((Player 1) + (Player 2) + (Player 3) + (Player 4) + (Player 5) + (Player 6) + (Player 7) + (Player 8))
            val Except
            {(when Except = true
            add 1 "Random Players" to "Team One Total Players")}
            val Exception
            {(when Exception = true
            add 1 "Random Players" to "Team Two Total Players")}
           var Buildstring: Team One Players = 1 "Random Players"
            var Buildstring: Team Two Players = 3 "Random Players"
            byteArrayOf: Team Two Players
            {
                Buildset: Team Two Players = ("Random Players" = 3 ) in "Team Two"
            }
            byteArrayOf: Team One Players
            {
                Buildset: Team One Players = ("Random Players" = 1) in "Team One"
            }
            if "all Players" = >4, let (Exception = true) in (Team One)
            +
            if "all Players" = >5, let (Exception = true) in (Team Two)
            +
            if all Players = >6, let (Exception = true) in (Team Two)
            +
            if all Players = >7, let (Exception = true) in (Team Two)

            //Player Spawning Places//
                 val player size is (100 units squared)
            ((100 units squared) = (x=0<x=100 and y=0<y=100)),
            fun (TeamTwoStartingPlayerPositions)
            {Buildset: 1 any(Team Two Players) = spawn to x=0<100 and y=0<100
            x=0<100 and y=0<100 is occupied
                Buildset: 1 any(Team Two Players) = spawn to x = 100<200 and y=0<100
            x=100<200 and y=0<100 is occupied
                Buildset: 1 any(Team Two Players) = spawn to x=200<300 and y=0<100
            x=300<400 and y=0<100 is occupied
          if 6 "all Players" = true, Buildset: 1 any(Team Two Players) = spawn to x=0<100 and y=900<1000
         then x=0<100 and y=900<1000 is occupied
            if 7 "all Players" = true, Buildset: 1 any(Team Two Players) = spawn to x=100<200 and y=900<1000
            then x=100<200 and y=900<1000 is occupied
            if 8 "all Players" = true, Buildset: 1 any(Team Two Players) = spawn to x=200<300 and y=900<1000
            then x=200<300 and y=900<1000 is occupied }

               fun (TeamOneStartingPlayerPositions)
               {Buildset: 1 any(Team One Players) = spawn to {x=200<300 and y=200<300
            x=200<300 and y=200<300 is occupied
            if 5< "all Players" = true, Buildset: 1 any(Team One Players) = spawn to x=300<400 and y=300<400
               then x=300<400 and y=300<400 is occupied}
